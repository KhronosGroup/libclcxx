#ifndef __OPENCL_TYPE_TRAITS
#define __OPENCL_TYPE_TRAITS

#if defined(__clang_major__) && (__clang_major__ > 11)

// These clang extensions are necessary to include type traits from C++17
#ifndef __cl_clang_function_pointers
#error "Missing __cl_clang_function_pointers extension support"
#endif
#pragma OPENCL EXTENSION __cl_clang_function_pointers : enable
#ifndef __cl_clang_variadic_functions
#error "Missing __cl_clang_variadic_functions extension support"
#endif
#pragma OPENCL EXTENSION __cl_clang_variadic_functions : enable
#include <type_traits>
#pragma OPENCL EXTENSION __cl_clang_function_pointers : disable
#pragma OPENCL EXTENSION __cl_clang_variadic_functions : disable

namespace std {

// add address spaces

template <typename T> struct add_generic { using type = __generic T; };
template <typename T> struct add_global { using type = __global T; };
template <typename T> struct add_private { using type = __private T; };
template <typename T> struct add_local { using type = __local T; };
template <typename T> struct add_constant { using type = __constant T; };

// has_address_space

template <typename T> struct has_address_space : public false_type {};

template <typename T>
struct has_address_space<__generic T> : public true_type {};
template <typename T>
struct has_address_space<__global T> : public true_type {};
template <typename T>
struct has_address_space<__private T> : public true_type {};
template <typename T> struct has_address_space<__local T> : public true_type {};
template <typename T>
struct has_address_space<__constant T> : public true_type {};

// is_generic

template <typename T> struct is_generic : public false_type {};
template <typename T> struct is_generic<__generic T> : public true_type {};

// is_global

template <typename T> struct is_global : public false_type {};
template <typename T> struct is_global<__global T> : public true_type {};

// is_private

template <typename T> struct is_private : public false_type {};
template <typename T> struct is_private<__private T> : public true_type {};

// is_local

template <typename T> struct is_local : public false_type {};
template <typename T> struct is_local<__local T> : public true_type {};

// is_constant

template <typename T> struct is_constant : public false_type {};
template <typename T> struct is_constant<__constant T> : public true_type {};

// remove_address_space

template <typename T> struct remove_address_space { using type = T; };

template <typename T> struct remove_address_space<__generic T> {
  using type = T;
};
template <typename T> struct remove_address_space<__global T> {
  using type = T;
};
template <typename T> struct remove_address_space<__private T> {
  using type = T;
};
template <typename T> struct remove_address_space<__local T> {
  using type = T;
};
template <typename T> struct remove_address_space<__constant T> {
  using type = T;
};

} // namespace std

#else
#error "Unsupported clang version - use clang-12 or later versions"

#endif /* if define __clang_major__ */
#endif /* define __OPENCL_TYPE_TRAITS  */
